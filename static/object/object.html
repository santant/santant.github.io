<!DOCTYPE html>
<html>
	<head>
		<link rel="shortcut icon" href="../../imges/ico.ico" type="images/x-icon" />
		<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />
		<link rel="stylesheet" type="text/css" href="../../css/public.css"/>
		<link rel="stylesheet" type="text/css" href="../../css/index.css"/>
		<script src="../../js/jquery-1.8.2.min.js" type="text/javascript" charset="utf-8"></script>
		<script src="../../js/index.js" type="text/javascript" charset="utf-8"></script>
		<meta charset="UTF-8">
		<title>面向对象</title>
		<script type="text/javascript" src="../../js/pre/scripts/shCore.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushBash.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushCss.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushCSharp.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushJScript.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushPhp.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushPlain.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushPython.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushJava.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushScala.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushSql.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushXml.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushPerl.js"></script>
		<link type="text/css" rel="stylesheet" href="../../js/pre/styles/shCore.css" />
		<link type="text/css" rel="stylesheet" href="../../js/pre/styles/shThemeDefault.css" />
		<script type="text/javascript">
			SyntaxHighlighter.defaults['toolbar'] = false;  //去掉右上角问号图标
			SyntaxHighlighter.config.tagName = 'pre';       //可以更改解析的默认Tag。
			SyntaxHighlighter.config.bloggerMode = true; 
			SyntaxHighlighter.config.stripBrs = true;  
			SyntaxHighlighter.all();
	   </script>
		<style type="text/css">
			
		</style>
	</head>
	<body>
	  <div class="hander"> 
	  	<ul>
	  		<li class="" nav-title="all"><a href="../../index.html">首页</a></li>
			<li nav-title="css" class=""> <a href="../canvas/demo1.html">Html5画布入门篇</a></li>
			<li nav-title="css" class=""><a href="../canvas/demo3.html">Html5画布提升篇</a></li>
			<li><a href="../CSS/css3.html">CSS3</a></li>			
			<li><a href="../../static/control/control.html">自己写的demo</a></li>			
			<li nav-title="rem工具换算"><a href="../../static/rem1/rem.html">rem</a></li>			
	  		<li><a href="../title/demo2.html">收藏的网站</a></li>
	  		<li ><a href="../tool/tool.html">工具箱</a></li>
	  		<li class=""><a href="../javascript/Event.html">javascriptEvent</a></li>
	  		<li class=""><a href="../javascript/jsDom.html">javascriptDOM</a></li>
	  		<li class=""><a href="../javascript/object.html">javascriptObj</a></li>	  		
	  		<li  ><a href="../zhengze/zhengze.html">js正则表达式</a></li>
	  		<li class=""><a href="../javascript/JSFcnction.html">javascript函数</a></li>
	  		<li class=""><a href="../HTML5/H5_1.html">HTML5</a></li>
	  		<li><a href="../angualar/angualar.html">angualarJS</a></li>
	  		<li class=""><a href="../jquery-css3/jq-css3.html">Jquery操作css3的拼接方式</a></li>	 
	  		<li class=""><a href="../less/less.html">less</a></li>
	  		<li class=""><a href="../git/git.html">git</a></li>
	  		<li class="active"><a href="object.html">面向对象</a></li>
	  	</ul>
	  </div>	
	  <!--git-->
	  <div class="main">
	  	 <h3>面向对象</h3>	  	 
	  	 <div class="div_daima">
	  	 	<h4>面向对象注意的问题</h4>	  	 	
			<pre class="brush:js">
				
				一个完整的 JavaScript 实现是由以下 3 个不同部分组成的：
				//1.核心（ECMAScript）、2.文档对象模型（Document Object Model，简称DOM）、3.浏览器对象模型（Browser Object Model，简称BOM）。
				
				js从面向对象来分的话(一切都是面向对象，分为3类)
				//1:内置对象 比如Math Data cookie session null object等等 2:BOM对象 window document等 3:自定义对象
				
				
				1:解析变量的时候，要从局部变量到全局变量
				//2:函数是什么？
				 1) ： 封装性
				 2) ：是个工具
				 
				//3.json和自变量   json是一种协议，手机pc等都支撑这种协议
				xml也行一种协议
				
				//4:defineProperty 过滤器
				
				//5:私有和共有属性,以及面向对象init的调用
				
				//6.数据类型判断 普通的typeof，但是他不能判断arry和对象他们都返回对象,用toString.call('')可以解决 ,instanceof和constructor了解
				
				//7.什么是原型链条
				 答：其实对象就是由2个独立的对象组成1个是原型对象，1个是构造函数对象，他们是通过_proto_联系在1起的（ie老版本不是通过这个实现的)
				 
				 //8.属性访问搜索法则（也就是原型链）
				 首先遍历自己的属性（从构造函数拷贝过来的属性），如果找到就返回
				 如果没找到，就根据铁链寻找到原型对象，依次遍历原型对象中的属性，如果找到同名的属性就返回，就这么简单。
				
				//9.hasOwnProperty : 看是不是对象自身下面的属性
				
				//10.想访问原型对象里面的方法  1.delete 删除构造函数的方法 2.直接 对象.protptype.属性和方法 
				
				
			</pre>
			<h4>方法<code>instanceof:判定某个实例是否根据某个构造函数创建的</code><code>defineProperty 包装器 writable:false的时候值不可修改</code></h4>
			<pre class="brush:js">
				//判定某个iphone是否根据Product这个构造函数创建的，返回布尔值
				console.log(iphone instanceof Product);
				
				//值的过滤器和限制 defineProperty 放在初始化值的函数里面
				Object.defineProperty(this,'price',{
					get:function(){return price*0.9}, //获取的值
					set:function(value){ //获取的值
						//大概普通产品的价格都在0-1万之间
						if(value >10000){
							alert('产品价格必须在0-1万之间')
						}else{
							price = value;
						}
					}
				})
				
				//权限 不可修改 ，定义这个的时候value就是永远固定住了
				Object.defineProperty(this,'price',{
					value:40000,
					writable:false//不可修改
				})
				
				//时间对象
				new Date().toLocaleDateString() //2016/11/2
				new Date().toLocaleString() //2016/11/2 下午2:59:03
			</pre>
	  	 	<h4>面向对象几种模式</h4>
	  	 	<pre class="brush:js">
	  	 	//混合模式
			function Product(name,price){
				this.name = '';
				this.price = 0;
				this.version = 1.0;
				this.add =function(){
					console.log("add方法");
				}
				//值的过滤器和限制 defineProperty
				Object.defineProperty(this,'price',{
					get:function(){return price*0.9},
					set:function(value){
						//大概普通产品的价格都在0-1万之间
						if(value >10000){
							alert('产品价格必须在0-1万之间')
						}else{
							price = value;
						}
					}
				})
//				//权限 不可修改 ，定义这个的时候value就是永远固定住了
//				Object.defineProperty(this,'price',{
//					value:40000,
//					writable:false//不可修改
//				})
			}
			Product.prototype = {};
			
			var iphone = new Product();
			//在添加自己特有的-->现在的东西就是函数里面的加上自己特有的
			iphone.description = 'xxxxx';
			iphone.Image = [];
			console.log(iphone);
			//判定某个iphone是否根据Product这个构造函数创建的
			console.log(iphone instanceof Product);		
			iphone.price = 10000;
			//包装值
			console.log(iphone.price);//在获得的时候这就是打9折的数据
	  	 </pre>
	  	 <h4>内存检测<code>数据类型判定 1.typeof 2.toString.call</code> <code>数据和对象typeof都返回object</code><code><a href="demo/shujuleixing.html">判断数据类型</a></code><code>instanceof判断是不是数据那个对象</code><code>constructor</code><code><a href="demo/jq_data.html">jquery判断数据类型方法</a></code></h4>
	  	 <pre class="brush:js">
	  	 	//typeof(数据和对象typeof都返回object)
	  	 	    console.log('数据类型判断 - typeof')
			    console.log(typeof undefined)//'undefined'
			    console.log(typeof null) // well-known bug
			    console.log(typeof true) //'boolean'
			    console.log(typeof 123)  //'number'
			    console.log(typeof "abc")  //'string'
			    console.log(typeof function() {}) //'function'
			    var arr=[];
			    console.log(typeof {}) //'object'
			    console.log(typeof arr)//'object'
			    console.log(typeof unknownVariable) //'undefined'
			    //    在使用 typeof 运算符时采用引用类型存储值会出现一个问题，
			    //    无论引用的是什么类型的对象，它都返回 "object"。
			    
	  	 	//toString.call
	  	 	/******************************************************************************
		     数据类型判断 - toString.call
		     通用但很繁琐的方法： prototype
		     *******************************************************************************/
		    console.log('数据类型判断 - toString.call')
		    console.log(toString.call(123))          //[object Number]
		    console.log(toString.call('123'))        //[object String]
		    console.log(toString.call(undefined))    //[object Undefined]
		    console.log(toString.call(true))         //[object Boolean]
		    console.log(toString.call({}))           //[object Object]
		    console.log(toString.call([]))           //[object Array]
		    console.log(toString.call(function(){})) //[object Function]
		    
		    
		    
	  	 </pre>
	  	 <h4>公有和私有属性以及方法<code>其实就看有没this和var</code> <code>私有成员的引用，不用加this</code></h4>
	  	 <pre class="brush:js">
	  	 	function Person(name){
	  	 		var nameclass = 'ddd';//私有属性
	  	 		this.name = name;//公有属性
	  	 		var private = function(){//私有方法
	  	 			alert('xx')
	  	 		}
	  	 		this.public = function(){//公有方法
	  	 			alert("公共的")
	  	 		}	  	 		
	  	 	}
	  	 	
	  	 	//在实际开发中匿名函数中的写法,弄1个this.init方法让外界访问
	  	 	function Person(name){
	  	 		//对于哪种常用的类似于选择器选中的dom，想要重复利用，在面向对象中一般定义1个对象保存
	  	 		/*避免重复，减少内存*/
		        /*统一管理*/
		       var that = this;
		        this.config = {
		            btnConfirm: document.getElementById('btn'),
		            btnBuy: document.getElementById('btn'),
		            btnAddCart: document.getElementById('btn'),
		            domProductName :  document.getElementById('pname'),
		            domProductPrice :  document.getElementById('pprice'),
		            sum :  1000		            
		        }
	  	 		var private = function(){//私有方法
	  	 			alert('xx')
	  	 			//这里想用到变量的时候只需要：that.config.btn就可以访问了
	  	 			that.config.btn.innerHTML='xxx';
	  	 		}
	  	 		var public = function(){//私有方法
	  	 			alert("公共的")
	  	 		}	
	  	 		//弄1个this.init方法让外界访问
	  	 		this.init = function(){
	  	 			private();//执行上面私有的方法
	  	 			public();//执行上面私有方法
	  	 		}	  	 		
	  	 	}
	  	 </pre>
	  	 <h4>实例化本质-内存</h4>
	  	 <pre class="brush:js">
			//一切数据都是保存在内存中.
			
			//内存分配会自动拷贝构造对象的所有属性，并赋以实例的值
			
			//当你实例化一个对象,那么内存中会开辟两个内存区域：
			
			1.一个保存实例名称变量：其保存的只是地址
			2.一个保存对象的真正的数据
	  	 </pre>
	  	 
	  	 <h4><code>原型对象</code><code>构造函数创建对象所存在的缺点</code></h4>
	  	 <pre class="brush:js">
			//构造函数缺点
			
			1.每次实例化都需要分配内存存储这些数据		
			2.如果实例很多，那就要分配很多内存存储
			
			//------------为了避免内存浪费我们就需要原型对象
			
			
			//原型对象
			
			1.原型对象中的工具被所有实例所共享  //原型对象本质： 原型对象的属性和方法可以被所有实例共享 这样，如果我们需要修改所有实例中的属性或者方法，就只需要修改一处，就能够影响到所有实例了

			2.原型对象，不管你实例化多少次，都只生成1次
			
			//总结：
			
			一般将大家都公有的东西放在原型对象中
			每个实例独特的不一样的属性放在构造函数中
	  	 </pre>
	  	 <h4>对象 <code>构造函数对象和原型对象是通过_proto_联系在1起的（ie老版本不是通过这个实现的）</code></h4>
	  	 <pre class="brush:js">
	  	 	//通过原型创建对象，其实创建的是两个对象(双对象法则)
			
			1.构造函数对象
			2.原型对象
	  	 </pre>
		  	 <h4>引用类型和值类型<code>在正常的情况下分配内存之后，修改同一个内存地址的值会影响其他只想这个地址的值</code><code>引用类型(数组,函数,对象,json,和内置对象)是存1个key和值,值类型是直接存值</code></h4>
		  	 <pre class="brush:js">
		  	 	var num1; //这个时候不进行内存分配
			    var num3=9;//分配内存
			    var num4=num3;//会不会分配
		  	 	 //    数组 ： 当定义一个新数组，
			    // 内存会产生两篇区域，一个存储变量，一个存储数组 变量中保存的只是数组所在的地址
			    var arr1=['传智播客','黑马'];//分配内存
			    //引用类型其实是指向同一个地址,也就是操纵的其实是同一个位置
			    var arr2=arr1;   //问题：这里arr2会不会分配内存
			    console.log(arr1[0]);
			    console.log(arr2[0]); //一样
			    
			    //修改数组1
			    arr2[0]='水浒传 西游记 三国演义 红楼梦';
			    console.log(arr1[0]);
			    console.log(arr2[0]);//一样 说明这里不分配内存，其实arr2变量中存的是地址，指向arr1内存		
			    
			    function show(x) {
			        console.log(typeof(x));    // undefined 值类型
			        console.log(typeof(10));   // number 值类型
			        console.log(typeof('abc')); // string 值类型
			        console.log(typeof(true));  // Boolean 值类型
			        console.log(typeof(function () { }));  //函数 引用类型
			        console.log(typeof([1, 'a', true]));  //数组  引用类型
			        console.log(typeof ({ a: 10, b: 20 }));  //object 或者json  引用类型
			        console.log(typeof (null));  //null  引用类型
			        console.log(typeof (new Number(10)));  //内置对象 引用类型
			    }
			    show();
			//    其中上面的四种（undefined, number, string, boolean）属于值类型，不是对象。
		  	 </pre>
		  	 <h4>堆和栈<code>内存分为两种堆内存和栈内存</code> <code>内存的生命周期</code></h4>
		  	 <pre class="brush:js">
		  	 	//栈 : 值类型保存在栈里面 类似1个数组
		  	 	//如何获取：通过下标和数组类似
		  	 	//堆 :引用类型
		  	 	demo：
		  	 	//var arr = [1,23,4] //arr栈 1，23，4堆
		  	 	
		  	 	//var p = new pserson();
		  	 	//p变量就是栈，（临时存储，函数执行完就被回收）
		  	 	//对象的属性和其他生成的全是:堆(会在内存中存在) 回收:引用计数 函数实例化1次+1，当引用计数为0时，系统自动回收
		  	 	
		  	 	内存的生命周期
		  	 	/**内存分配：
				当我们申明变量、函数、对象的时候，系统会自动为他们分配内存
				内存使用 var name=null：
				即读写内存，也就是使用变量、函数等
				内存回收：
				使用完毕，由垃圾回收自动回收不再使用的内存**/
				
				总之：
				一切数据通过变量来管理和存储的
				定义变量的过程其实就是内存分配的过程
				所以本质上一切数据都是存放在内存中的
		  	 </pre>
	  	</div>	 
	  </div>	  
	   <!--返回顶部-->
	  <div id="div-Top">
		  	<dl>
		  		<dd>
		  			<img src="../../img/weixin-icon02.png"/></li>
		  		</dd>
		  		<dt class="weixin">
		  			<div></div>
		  		</dt>
		  		<dt class="to_top">
		  			<div></div>
		  		</dt>
		  		
		  	</dl>
	  </div>
	</body>
</html>
