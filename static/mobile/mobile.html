<!DOCTYPE html>
<html>
	<head>
		<link rel="shortcut icon" href="../../imges/ico.ico" type="images/x-icon" />
		<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />
		<link rel="stylesheet" type="text/css" href="../../css/public.css"/>
		<link rel="stylesheet" type="text/css" href="../../css/index.css"/>
		<script src="../../js/jquery-1.8.2.min.js" type="text/javascript" charset="utf-8"></script>
		<script src="../../js/index.js" type="text/javascript" charset="utf-8"></script>
		<meta charset="UTF-8">
		<title>移动端详解</title>
		<script type="text/javascript" src="../../js/pre/scripts/shCore.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushBash.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushCss.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushCSharp.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushJScript.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushPhp.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushPlain.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushPython.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushJava.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushScala.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushSql.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushXml.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushPerl.js"></script>
		<link type="text/css" rel="stylesheet" href="../../js/pre/styles/shCore.css" />
		<link type="text/css" rel="stylesheet" href="../../js/pre/styles/shThemeDefault.css" />
		<script type="text/javascript">
			SyntaxHighlighter.defaults['toolbar'] = false;  //去掉右上角问号图标
			SyntaxHighlighter.config.tagName = 'pre';       //可以更改解析的默认Tag。
			SyntaxHighlighter.config.bloggerMode = true; 
			SyntaxHighlighter.config.stripBrs = true;  
			SyntaxHighlighter.all();
	   </script>
		<style type="text/css">
			
		</style>
	</head>
	<body>
	  <div class="hander"> 
	  	<ul>
	  		<li class="" nav-title="all"><a href="../../index.html">首页</a></li>
			<li nav-title="css" class=""> <a href="../canvas/demo1.html">Html5画布入门篇</a></li>
			<li nav-title="css" class=""><a href="../canvas/demo3.html">Html5画布提升篇</a></li>
			<li><a href="../CSS/css3.html">CSS3</a></li>			
			<li><a href="../../static/control/control.html">自己写的demo</a></li>			
			<li nav-title="rem工具换算"><a href="../../static/rem1/rem.html">rem</a></li>			
	  		<li><a href="../title/demo2.html">收藏的网站</a></li>
	  		<li ><a href="../tool/tool.html">工具箱</a></li>
	  		<li class=""><a href="../javascript/Event.html">javascriptEvent</a></li>
	  		<li class=""><a href="../javascript/jsDom.html">javascriptDOM</a></li>
	  		<li class=""><a href="../javascript/object.html">javascriptObj</a></li>	  		
	  		<li  ><a href="../zhengze/zhengze.html">js正则表达式</a></li>
	  		<li class=""><a href="../javascript/JSFcnction.html">javascript函数</a></li>
	  		<li class=""><a href="../HTML5/H5_1.html">HTML5</a></li>
	  		<li><a href="../angualar/angualar.html">angualarJS</a></li>
	  		<li class=""><a href="../jquery-css3/jq-css3.html">Jquery操作css3的拼接方式</a></li>	 
	  		<li class=""><a href="../less/less.html">less</a></li>
	  		<li class=""><a href="git.html">git</a></li>
	  		<li class=""><a href="git.html">移动事件</a></li>
	  	</ul>
	  </div>	
	  <!--git-->
	  <div class="main">
	  	 <h3>mobile </h3>	  	 
	  	 <div class="div_daima">
	  	 	<h4>移动端布局注意哪点事儿<code>解决横竖屏切换字体比例的问题</code><code>默认字体Helvetica</code> <code>点击黑块儿黑屏</code> <code>ios下的圆角</code></h4>
	  	 	<pre class="brush: css;">
	  	 		 .xx{-webkit-text-size-adjust: 100%; //解决横竖屏切换字体比例的问题
	  	 		
	  	 		 body{
	  	 		 	 font-family: Helvetica; //所有手机都有的默认字体Helvetica	  	 		 	 
	  	 		 }
	  	 		 
	  	 		 a,input,button {
				  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);//解决点击黑块儿的问题
				  -webkit-appearance: none; //清除input，button，等在ios下的圆角
				  outline: none;//清除虚线
				}
				
				
	  	 	</pre>
	  	 	<h4>移动事件 </h4>
	  	 	<pre class="brush: js;">		
	  	 	/* 
				touchstart 手指触摸 == mousedown 
				touchend 手指抬起 == mouseup
				touchmove 手指抬起 == mousmove				
				touch事件  在 chrome的模拟器下，部分版本 通过on的方式来添加事件无效
				
				touchstart 手指触摸 == mousedown 
				touchend 手指抬起 == mouseup
				touchmove 手指抬起 == mousmove
				
				touch事件  在 chrome的模拟器下，部分版本 通过on的方式来添加事件无效
				
				addEventListener("事件名",函数,冒泡或捕获);
				1. 不会存在前后覆盖问题
				2. 在chrome的模拟器下可以一直识别
			*/
			冒泡 ：点击元素 他会把这个事件一直向上传递 从下向上传递
			捕获 ：从上向下传递
			
			//阻止事件
			e.preventDefault(); 阻止默认事件
	
			阻止掉：document touchstart的默认事件，可以解决一下问题：
				1. 阻止页面上的文字被选中    -- 可以通过阻止冒泡使某个元素上的文字被选中
				2. 阻止页面上的系统菜单
				
			隐患:
				页面上的所有滚动条失效	
			
			阻止 document的 	touchstart 或者 touchmove，可以清除系统默认的回弹
			//事件点透
			PC端鼠标事件 在移动端也可以正常使用，但是注意 事件的执行 会有300ms的延迟	
			事件点透：
				1. 在移动端 PC事件 有 300ms的延迟
				2. 我们点击了页面之后，浏览器会记录点击下去的坐标
				3. 300ms后，在该坐标找到现在在这的元素 执行事件
			解决办法：
				1. 阻止默认事件	(部分安卓机型不支持)
				2. 不在移动端使用鼠标事件，不用a标签做页面跳转
			//防止误碰
			document.addEventListener(
			    "touchstart",
			    function(e) {
			        e.preventDefault();
			    }
			);
			window.onload = function () {
			    var a = document.querySelectorAll("a");
			    for(var i = 0; i < a.length; i++) {
			        a[i].addEventListener(
			            "touchmove",
			            function() {
			                this.isMove = true;
			            }
			        );
			        a[i].addEventListener(
			            "touchend",
			            function() {
			                if(!this.isMove) {
			                    window.location.href = this.href;
			                }
			                this.isMove = false;
			            }
			        );
			    }
			};
	  	 	</pre>	
	  	 	<h4>touch事件，以及简易的滑屏原理 <code>ev.touches.length//手指的个数</code> <code><a href="mobileDemo/huaping.html">简单的手机滑屏</a></code></h4>
	  	 	<pre class="brush: js;">
	  	 	/*
				touches 当前屏幕上的手指列表
				targetTouches 当前元素上的手指列表
				changedTouches 触发当前事件的手指列表，这个一般最常用
			*/
			//1.手指按下的时候，记录下手指的坐标，移动的时候，同样记录手指坐标
			//2.然后用移动后的坐标－移动前的坐标 ＝ 手指移动的距离
			//3.手指按下去之后，记录下元素的位置
			//4.移动之后，用手指移动的记录＋元素的初始化的位置 ＝ 元素现在的位置
window.onload = function(){
		var oWrap = document.getElementById("wrap");
		var oScroll = document.getElementById("scroll");
		var startPoint = 0;//手指初始的位置
		var startEl = 0;//滚动区域距顶部的位置
		//手指移动的最大高度 ＝ 大盒子的内容高度 － 小盒子的实际高度
		var MaxTop = oWrap.clientHeight - oScroll.offsetHeight; 
		console.log(MaxTop);
		oWrap.addEventListener("touchstart",function(ev){
			var touchs = ev.changedTouches[0];
			startPoint = touchs.pageY;//开始触摸的位置
			startEl = oScroll.offsetTop;//滚动区域距顶部的位置
			console.log(startPoint);
		})
		oWrap.addEventListener("touchmove",function(ev){
			var touchs = ev.changedTouches[0];
			var nowPoint = touchs.pageY;//手指移动的距离
			//1.手指按下的时候，记录下手指的坐标，移动的时候，同样记录手指坐标
			//2.然后用移动后的坐标－移动前的坐标 ＝ 手指移动的距离
			//3.手指按下去之后，记录下元素的位置
			//4.移动之后，用手指移动的记录＋元素的初始化的位置 ＝ 元素现在的位置
			var dis = nowPoint - startPoint;//手指移动的距离
			var top = startEl+dis;
			if (top>0) {//限制滑动的距离
				top = 0;
			}
			if(top < MaxTop){
				top = MaxTop;
			}
			oScroll.style.top = top+'px';
		})			
	}
	  	 	</pre>
	  	 	<h4>设置和获取css3函数<code>如果要获取 transform的值，必须是通过这个函数设置 才能通过这个函数获取到</code></h4>
	  	 	<pre class="brush: js;">
	  	 	function cssTransform(el,attr,val) {
				if(!el.transform){//没有就创建这个对象
					el.transform = {};
				}
				if(arguments.length>2) {//参数>2,设置
					el.transform[attr] = val;
					var sVal = "";
					for(var s in el.transform){
						switch(s) {
							case "rotate":
							case "skewX":
							case "skewY":
								sVal +=s+"("+el.transform[s]+"deg) ";
								break;
							case "translateX":
							case "translateY":
								sVal +=s+"("+el.transform[s]+"px) ";
								break;
							case "scaleX":
							case "scaleY":
							case "scale":
								sVal +=s+"("+el.transform[s]+") ";
								break;	
						}
						el.style.WebkitTransform = el.style.transform = sVal;
					}
				} else {//获取值
					val  = el.transform[attr];
					if(typeof val == "undefined" ) {//等于undefined
						if(attr == "scale" || attr == "scaleX" || attr == "scaleY"  ) {
							val = 1;//缩放默认为1；
						} else {
							val = 0;//一般的都是默认为0；
						}
					}
					return val;
				}
			}
			window.onload = function() {
				var div = document.querySelector("#div");//节点
				cssTransform(div,"rotate",45);//设置
				console.log(cssTransform(div,"rotate"));//获取
				// 如果要获取 transform的值，必须是通过这个函数设置 才能通过这个函数获取到
			};
	  	 	</pre>
	  	 	<h4>无缝滚动轮播<code><a href="mobileDemo/mobile_lunbo.html">无缝滚动轮播</a></code></h4>
	  	 	<pre  class="brush: js;">
	  	 		document.addEventListener(
					"touchstart",
					function (e){
						e.preventDefault();
					}
				);
				window.onload = function (){
					var wrap = document.querySelector("#wrap");//外边框盒子
					var list = document.querySelector("#list");//运动的dom
					list.innerHTML+=list.innerHTML;//复制一组
					var lis = document.querySelectorAll("#list li");//li图片
					var css = document.querySelector("#css");
					var nav = document.querySelectorAll("#nav span");//底部状态栏
					wrap.style.height = lis[0].offsetHeight+'px';//算出高度
					list.style.width = lis.length+'00%';//算出宽度
					for (var i = 0; i < lis.length; i++) {//小li的宽度
						lis[i].style.width = 100/lis.length+'%';
					}
					var startPoint = 0;//手指初始坐标
					var startX = 0;//元素初始位置
					var timer = null;//定时器
					var now2 = 0;//now自动播放索引
					
					//cssTransform设置下需要移动的translateX
					cssTransform(list,"translateX",0);	
					auto();//要在设置了这个变量之后才能调用自动播放函数
				   	wrap.addEventListener("touchstart",function(ev){ 
				   			clearInterval(timer);
				   			list.style.transition = "none";//先清除动画
							var translateX = cssTransform(list,"translateX");
							var now = Math.round(-translateX / wrap.offsetWidth);
							if(now == 0) {//等于0的时候，跳到下一组
								now = nav.length;
							}
							if(now == lis.length-1) {//最后一组的时候，跳到最后一组
								now = nav.length-1;
							}
							cssTransform(list,"translateX",-now * wrap.offsetWidth);
							startPoint = ev.changedTouches[0].pageX;//手指点入初始化坐标
							startX = cssTransform(list,"translateX");//拖动dom元素初始位置
							
				   	})
				   	wrap.addEventListener("touchmove",function(ev){
				// 		list.style.transition = 'none';
				   		var touchs = ev.changedTouches[0];//手指对象
				   		nowPoint = touchs.pageX;//手指移动时候的坐标
				   		var dis =  nowPoint - startPoint;//手指移动的距离(判定向上向下，全看这个)
				   		cssTransform(list,"translateX",startX + dis);//物体该位移的值
				   	})
				   	wrap.addEventListener('touchend',function(ev){
				   		
				   		//获取translateX
				   		var translateX = cssTransform(list,"translateX");//离开屏幕的时候获取到运动dom位移的translateX值		
				   		//now = (-离开屏幕的时候获取到运动dom运动的left值-运动dom本来的宽度)
				   		var now = Math.round(-translateX/wrap.offsetWidth); //到底到几个来了
						list.style.transition = '0.5s';//动画时间
						cssTransform(list,"translateX",-now*wrap.offsetWidth);	
						now2 = now;	//统一索引
						auto();//再次调用自动播放
						//和状态栏关联
						for (var i = 0; i < nav.length; i++) {
							nav[i].className = "";
						}
						nav[now%nav.length].className = "active";
				   	})
				   	function auto(){//自动播放
				   		timer = setInterval(function(){  			
				   			if (now2 == lis.length-1) {
				   				now2 = nav.length-1;
				   				list.style.transition = '0s';
				   				cssTransform(list,"translateX",-now2*wrap.offsetWidth);
				   			}
				   			setTimeout(function(){//让js加载有个缓冲时间	
				   				now2++;
				   				list.style.transition = '0.5s';
					   			cssTransform(list,"translateX",-now2*wrap.offsetWidth);
					   			//和状态栏关联
								for (var i = 0; i < nav.length; i++) {
									nav[i].className = "";
								}
								nav[now2%nav.length].className = "active";
				   			},30)
				   		},3000)
				   	}  	
				};
	  	 	</pre>
	  	 	<h4>js实现跟随手指横向滑动，<code><a href="mobileDemo/hengxianghuadong.html">两边回弹</a></code> <code>只要有3d属性就可以用硬件加速</code></h4>
	  	 	<pre  class="brush: js;">
	  	 		window.onload = function(){
					document.addEventListener("touchmove",function(ev){
						ev.preventDefault();
					})
					//手写横向的滑动
					var oUL = document.getElementById("navs");
					//cssTransform设置下需要移动的translateX
					cssTransform(oUL,"translateZ",0);
					cssTransform(oUL,"translateX",0);
					var startPoint = 0;//手指开始的位置
					var startEl = 0;//物体运动的位置	
					var minX = 0;//超出的最小值
					var maxX = 0;//超出的最大值
					var minsX = oUL.offsetWidth - document.body.offsetWidth;//最小值－>向右运动的最大差值
					oUL.addEventListener("touchstart",function(ev){
				
						oUL.style.transition = 'none';
						var touchs = ev.changedTouches[0];//手指对象
				   		startPoint = touchs.pageX;//手指移动时候的坐标
				   		//在拖动的时候获取到当前运动到的位置
				   		startEl = cssTransform(oUL,"translateX"); 		
					})
					oUL.addEventListener("touchmove",function(ev){
						oUL.style.transition = 'none';
						var touchs = ev.changedTouches[0];//手指对象
				   		nowPoint = touchs.pageX;//手指移动时候的坐标   		
				   		console.log(startEl);
				   		//手指移动的坐标
				   		var dis = nowPoint - startPoint; 
				   		var left = dis+startEl;
				   		if (left>0) {
				   			//>0的时候让它缓慢拖动，现在只需要修改left的倍数就ok
				   			left=parseInt(left*0.4);  		
				   		}
				   		if (left < -minsX) {
				   			var over = -minsX -left//右边超出值
				     		left =-minsX-over*0.4;
				   		}
				   		cssTransform(oUL,"translateZ",0);
				   		cssTransform(oUL,"translateX",left);   		
					})
					oUL.addEventListener("touchend",function(ev){
						oUL.style.transition = '0.5s';
						var translateX = cssTransform(oUL,"translateX"); 		
						if (translateX>0) {
							cssTransform(oUL,"translateZ",0);
							cssTransform(oUL,"translateX",0);
						}
						if (translateX < -minsX) {
							cssTransform(oUL,"translateZ",0);
							cssTransform(oUL,"translateX",-minsX);
						}
					})
				}
	  	 	</pre>
	  	 	<h4>滑动的tab标签 <code><a href="mobileDemo/swipeTab.html">滑动的tab标签</a></code> <code>以及通过判定2次移动的pageX或者Y值来规定滑动的手势</code></h4>
	  	 	<pre  class="brush: js;">
				window.onload = function(){
					document.addEventListener("touchmove",function(ev){
						ev.preventDefault();
					})	
					tab();
					//滑动tab
					function tab(){
						var tabList = document.querySelectorAll(".tabList");//内容
						var tabUl = document.querySelectorAll(".tabList ul");
						var tabNav = document.querySelectorAll(".tabNav");//导航
						var width = tabNav[0].offsetWidth;
						var ospan = document.querySelector(".tabNav >span");
						for (var i = 0; i < tabNav.length; i++) {			
							swipe(ospan,tabList[i]);
						}
						console.log(ospan);
						function swipe(nav,list){//导航条，内容
						    var startPoint = 0;//手指初始的位置
							var nowPoint = 0;//手指移动时候坐标
							var num = 1;//初始化的索引
							cssTransform(nav,"translateX",ospan.offsetWidth*num);
							cssTransform(list,"translateX",-width*num);//显示在中间
							list.addEventListener('touchstart',function(ev){
								startPoint = ev.changedTouches[0].pageX;			
							})
							list.addEventListener('touchmove',function(ev){
								nowPoint = ev.changedTouches[0].pageX;//手指移动时候坐标
				//				console.log(startPoint);
				//				console.log(nowPoint);
								cssTransform(list,"translateX",nowPoint-startPoint-width*num);
								//在拖动的时候获取到当前运动到的位置
				       		    //startEl = cssTransform(list,"translateX"); 				
							});
							list.addEventListener('touchend',function(ev){
								//console.log(nowPoint-startPoint)
								var left = nowPoint-startPoint;//两边的差值
								if (left >100) {//向右边
									if (num < 2) {
										num =1
									}
									num--;
									cssTransform(nav,"translateZ",0);
									cssTransform(list,"translateX",-width*num);	
									cssTransform(nav,"translateX",ospan.offsetWidth*num);
								}else{//还原
									 list.style.transition = '0.5s';
									 cssTransform(nav,"translateZ",0);
									 cssTransform(list,"translateX",-width*num);	
								}
								if (left < -100) {//向左边	
									if (num > tabUl.length-2) {
										num = tabUl.length-2
									}
									console.log(num+'左边')
									 num++;
									 cssTransform(nav,"translateZ",0);
									 cssTransform(nav,"translateX",ospan.offsetWidth*num);
									 cssTransform(list,"translateX",-width*num);
								}else{//还原
								   list.style.transition = '0.5s';
								   cssTransform(nav,"translateZ",0);
								   cssTransform(list,"translateX",-width*num);	
								}				
							})
						}
						
					}
				}
	  	 	</pre>
	  	 	<h4>css3+js生成3d多棱柱<code>生成多边形函数</code><code><a href="mobileDemo/linzhu.html">生成多边形函数demo</a></code><code><a href="mobileDemo/loading.html">灵活的loading字体</a></code><code><a href="mobileDemo/qqhuadong.html">模仿移动端模仿qq滑动功能</a></code></h4>
	  	 	<pre  class="brush: js;">
	  	 	window.onload = function(){
					var div = document.getElementById("div");
					var html = '';
					var width = 100;
					var n =3;//几边形
					var deg = 360/n;//外角
					//(180-deg)/2,就是夹脚-->夹脚转弧度			
					var center = -Math.tan((180-deg)/2*Math.PI/180)*(width/2);//基点的z轴
					
					for (var i = 0; i < 10; i++) {
						html+="<span style='transform-origin: center center "+center.toFixed(2)+'px;transform: rotateY('+deg*i+'deg);'+"'>"+i+"</span>";
					}
					div.innerHTML = html;
		//			div.style.webkitTransformOrigin = "center center "+center+"+'px'";
					div.style.webkitTransformOrigin = "center center "+center.toFixed(2)+"px";
					console.log(div.style.webkitTransformOrigin)
				}
	  	 	</pre>
			<h4>注意问题集合</h4>
	  	 	<pre  class="brush: js;">
	  	 	//1.移动对象事件ev对象公用问题，解决方式：用对象存1下
		  	list.addEventListener(
				"touchstart",
				function(ev) {
					startPoint = {pageX:ev.changedTouches[0].pageX,pageY:ev.changedTouches[0].pageY};					
				}
			);
	  	 	//本来这里直接e.changedTouches[0].pageX就可以获得，但是他们会公用1个对象，用对象存1下可解决
	  	 	startPoint = {pageX:e.changedTouches[0].pageX,pageY:e.changedTouches[0].pageY};
	  	 	
	  	 	
	  	 	//2.如果在webkit内核下的浏览器 出现transition的闪烁问题：
	  	 	
	  	 	 //1)－>开启3d加速 解决方式：Z轴要有值，哪怕是0.1也可以  cssTransform(oUL,"translateZ",0.01);
	  	 	 
	  	 	 //2)给元素本身加上 隐藏背面  -webkit-backface-visibility: hidden; backface-visibility: hidden;
	  	 	 
	  	 	 //3)给运动元素父级加上 -webkit-transform-style: preserve-3d; transform-style: preserve-3d;	
	  	 	 
	  	 	
	  	 	</pre>	
	  	 </div>	 	
	  </div>
	  
	   <!--返回顶部-->
	  <div id="div-Top">
		  	<dl>
		  		<dd>
		  			<img src="../../img/weixin-icon02.png"/></li>
		  		</dd>
		  		<dt class="weixin">
		  			<div></div>
		  		</dt>
		  		<dt class="to_top">
		  			<div></div>
		  		</dt>
		  		
		  	</dl>
	  </div>
	</body>
</html>
