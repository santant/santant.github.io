<!DOCTYPE html>
<html>
	<head>
		<link rel="shortcut icon" href="../../imges/ico.ico" type="images/x-icon" />
		<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no" />
		<link rel="stylesheet" type="text/css" href="../../css/public.css"/>
		<link rel="stylesheet" type="text/css" href="../../css/index.css"/>
		<script src="../../js/jquery-1.8.2.min.js" type="text/javascript" charset="utf-8"></script>
		<script src="../../js/index.js" type="text/javascript" charset="utf-8"></script>
		<meta charset="UTF-8">
		<title>node课件笔记</title>
		<script type="text/javascript" src="../../js/pre/scripts/shCore.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushBash.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushCss.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushCSharp.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushJScript.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushPhp.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushPlain.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushPython.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushJava.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushScala.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushSql.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushXml.js"></script>
		<script type="text/javascript" src="../../js/pre/scripts/shBrushPerl.js"></script>
		<link type="text/css" rel="stylesheet" href="../../js/pre/styles/shCore.css" />
		<link type="text/css" rel="stylesheet" href="../../js/pre/styles/shThemeDefault.css" />
		<script type="text/javascript">
			SyntaxHighlighter.defaults['toolbar'] = false;  //去掉右上角问号图标
			SyntaxHighlighter.config.tagName = 'pre';       //可以更改解析的默认Tag。
			SyntaxHighlighter.config.bloggerMode = true; 
			SyntaxHighlighter.config.stripBrs = true;  
			SyntaxHighlighter.all();
	   </script>
		<style type="text/css">
			h3 a{color: #CC573D;}
		</style>
	</head>
	<body>
	  <div class="hander"> 
	  	<ul>
	  		<li class="" nav-title="all"><a href="../../index.html">首页</a></li>
			<li nav-title="css" class=""> <a href="../canvas/demo1.html">Html5画布入门篇</a></li>
			<li nav-title="css" class=""><a href="../canvas/demo3.html">Html5画布提升篇</a></li>
			<li><a href="../CSS/css3.html">CSS3</a></li>			
			<li><a href="../../static/control/control.html">自己写的demo</a></li>			
			<li nav-title="rem工具换算"><a href="../../static/rem1/rem.html">rem</a></li>			
	  		<li><a href="../title/demo2.html">收藏的网站</a></li>
	  		<li ><a href="../tool/tool.html">工具箱</a></li>
	  		<li class=""><a href="../javascript/Event.html">javascriptEvent</a></li>
	  		<li class=""><a href="../javascript/jsDom.html">javascriptDOM</a></li>
	  		<li class=""><a href="../javascript/object.html">javascriptObj</a></li>	  		
	  		<li  ><a href="../zhengze/zhengze.html">js正则表达式</a></li>
	  		<li class=""><a href="../javascript/JSFcnction.html">javascript函数</a></li>
	  		<li class=""><a href="../HTML5/H5_1.html">HTML5</a></li>
	  		<li><a href="../angualar/angualar.html">angualarJS</a></li>
	  		<li class=""><a href="../jquery-css3/jq-css3.html">Jquery操作css3的拼接方式</a></li>	 
	  		<li class="active"><a href="../less/less.html">less</a></li>
	  		<li class="active"><a href="git.html">git</a></li>
	  	</ul>
	  </div>	
	  <!--git-->
	  <div class="main">
	  	 <h3>node课件笔记<code><a href="#q1">7-24</a></code> <code><a href="#q2">7-31</a></code> <code><a href="#q1">7-24</a></code> <code><a href="#q3">8-7</a></code> <code><a href="#q4">8-14</a></code> <code><a href="#q5">8-24</a></code> <code><a href="#q6">9-4</a></code> <code><a href="#q7">9-11</a></code></h3>	  	 
	  	 <div class="div_daima">
	  	 	<h4 id="q1">7-24</h4>
	  	 	<pre class="brush: js;" id="q1">		
	  	 		html5——标准

					浏览器
				
				基础: js
				nodeJs
				
				js——应用
				
				ECMA(ECMAScript)——ES5 ES6  ES7 ES8
					标准——词法、语法
				DOM
				BOM
				
				ECMA语法规范：
					var a=12;
					if(){}
					for
				
					数组:
					var arr=[];
						arr.push()/arr.unshift().....
					字符串:
					var str='';
						str.substring()
				
				
				方法——对象身上一个行为
				属性——对象身上一个特性
				
				ES5、ES6——越来越接近后台
				----------------------------------
				作用域:	函数
				
				块级作用域:
					{}
					if(){}
					for(){}
					
					IIFE——自执行匿名函数
					(function(){
						alert(1);	
					})();
				
					{
				
					}
				
				定义变量:
					之前	var a=12;
					现在	let a=12	存在块级作用域
				常量:	固定不变，定义好这个值，不会改变
					之前	var a=12;
					现在	const a=12;	存在块级作用域
				
					注意：const a;
					        a=12;	//×
					        alert(a);
				函数:——箭头函数
					=>
				
					function show(){
						return 1;
					}
					show();
				
					function show(a){
						return a;
					}
					show(1);
				
				
					var show=a=>a;  -> function show(a){return a};
					var show=(a)=>a;  -> function show(a){return a};
					var show=()=>1;   -> function show(){return 1};
				
					(参数,参数) => {
						语句
					}
				
				定义一个类:	面向对象
					function Person(){	构造函数/类
				
					}
					
					class Person{ //类
					            constructor(name,age){ //构造函数，直接执行
					                this.name=name;
					                this.age=age;
					            }
				
					            showName(){
					                return this.name;
					            }
				        }
				---------------------------------------
				js
				
				NodeJs:
					什么是nodeJs?
						用Js编写一门后台语言
				
					后台语言: java	php	.net
				
					官网：https://nodejs.org/en/
				
					新语言
				
					2009	nodeJs成立
					2011	nodeJs发布第一版
						Npm出来
					之前	0.12.x
					2013	nodeJs分裂了，io.js
					2013	io持续更新
					2014	合并了，发布版本  4.x.x, 开始使用
					2015	两个大版本
				
					
				              v4.4.7 LTS:	长期支持版， 修改补丁
				              v6.3.1 Current(stable): 现在版本，各种新的东西，实验为主
				
				
					性格：沉稳-> LTS
					          尝鲜-> Current
				              
				NodeJs优势：
					1. 性能高	比php高86倍
					2. 容易学习	用js编写
					3. 整合容易	前端js，后台js
				
					* 堪比底层语言
				
					node	2台	4W	-> 省钱
					php	172台	344W
				
					响应速度
					node	1s
					php	86s	一分半
				NodeJs劣势： 
					太年轻， 不是那么成熟
					1. 给力学习资料太少 
					2. 对整体成员要求极高——前端(js)      后台知识
					3. 一切都得自己编写，容易出错
						php里面，一切都是现成的
				
				
				哪些公司在用？ BAT
				
					总结：性能高
				
				nodeJs特点：采用chrome V8
				
				JAVA
				PHP
					环境支持
				
				.php
				
				https://nodejs.org/en/download/  -> 下一步
				
				验证环境是否ok?
				
					win+r	-> cmd	-> node --version
								     node -v
				
					多验证一个？
							npm -v
				
					如果出来不是内部或者外部命令，——重启机器
				
				REPL:	read eval print loop 读取—解析—输出—循环
					编写nodejs
				
					测试一些node程序
				
					退出REPL环境：
						ctrl+c	按两次
				
				.js	新建js程序
				
				DOS命令:
					切换盘符	f:
					切换目录	cd 目录名
					清屏		cls
					查看目录下所有东西	dir
				
				运行node程序：
					node 文件名称	(文件后缀可以省略的)
				
					C:\Users\strive>f:
					F:\>cd 2016-7-24
					F:\2016-7-24>node 1.js
					well well
				
					简便办法: 按住 shift+右键
				
				node按理说，都是支持的，最好加上严格模式
					'use strict';
				
				nodeJs后台
				
				在node中，以下两个东西不能用：
				1. DOM	document
				2. BOM	window
				
				
				魔术变量(全局提供的东西)：
					node中自己封装一个 定时器(setInterval,setTimeout)
				
					__dirname	当前路径
					__filename	包含本身文件名路径
				
				在node中：
				1. 文件操作
				2. 数据库....
				-------------------------------------------
				后台——服务器
				
					ftp服务器
					dhcp服务器
					.....
				
					http服务器(web服务器)
				
				协议：——多方共同商量好的一个东西，大家必须都得遵守
				
				http协议:
					客户端和后台
					
					http rfc2612
				
					看懂此协议——疯掉
				
					模块——封装好的一个大对象
				
						系统(安装好node环境)自己提供模块——系统模块(内置模块)
				
				http服务器：
				
				回调函数：使用者， 只是定义	
				
				自己编写服务器:
				
					http模块
				
					1. 引入模块
						const http=require('http');
					2. 建服务器
						http.createServer(function(){});
					3. 端口号
						类似 门牌号
				
						监听端口号
				
						端口号，可以自己编写
				
						1-65535
				
						8081
					4. 通信
						function(request,response){}
				
						request.url	客户端地址
						response.write('well');	输出东西， 最好字符串
						response.end()		结束请求
				
				瑕疵：
					1. 每次输出一大段恶心html代码 ——恶心
					2. 每次修改前端代码，还需要重启服务器——不行
				------------------------------------
				读取文件里面内容:
					
					fs	file system	文件相关操作， 系统模块
				
					读取内容：
					fs.readFile(路径,[编码],function(err,data){	//异步过程
						
					})
				
				http+fs:
					浏览器：
						localhost:8081	->index.html
						localhost:8081/a   -> a.html
						localhost:8081/b   -> b.html
				
					异步:同时可以进行多个操作
					同步: 前一个操作没有完事，后一个不能开始
				------------------------------------------
				nodeJs核心开发：
					系统模块
					数据解析
					自定义模块
					Events
					buffer
					压缩
					....
				各种框架 mvc:
					前端模板: jade/ejs.....
					express
				网络：
					协议
					爬虫
				其他:
					noSql(mongo\redis\m...)
					....
			</pre>
			<h4 id="q2">7-31</h4>
			<pre class="brush: js;" >	
				上周:
	ES6基础知识

	块级作用域：
		{}
		let
		const
	箭头函数：
		=>

		var a=a=>a;

		function a(a){
			return a;
		}

		var show=()=>1;

		function show(){
			return 1;
		}

		var show=()=>{
			语句
		}
js组成部分：
	ECMA
	DOM
	BOM

js:
	core JavaScript
	client JavaScript	

node:	用js编写后台语言

	不能使用 DOM、BOM（client JavaScript）

	版本:

验证环境是否ok？
	win+r -> cmd -> node -v/npm -v

REPL:	书写nodejs
	进入: node

	可以测试代码
---------------------------------------------
nodeJs后缀  .js

	1.js	√
	1.node

运行:  	node	文件名

请解释一下xhr对象?
	var xhr=new XMLHttpRequest();


编写自己http服务器:
	http

fs——文件相关操作

	读取文件：
		fs.readFile(path,[编码],fnCb)

		function(err,data){
			
		}

错误信息：ENOENT	文件地址(路径)有问题

	fs.readFile(path,'utf-8',function(err,data){})

	fs.readFile(pathfunction(err,data){
		data.toString();  -> 跟utf-8结果一样的
	})

	* node里面关于文件操作，提供两套用法，一套异步，一套同步
		fs.readFile
		fs.readFileSync	读取关键配置文件
--------------------------------------------------------
文件相关操作:
	读取: fs.readFile
	创建文件:   fs.writeFile(path,内容,fnCb);
	追加内容:   fs.appendFile(path,内容,fnCb)	如果没有文件，创建并且添加
	删除文件： fs.unlink(path,fnCb)
	判断文件是否存在:  fs.exists(path,fnCb)
	查看文件状态:	fs.stat(path,fnCb)
				size	文件大小
				atime		access time	访问文件时间
				mtime		modiefied  time 最后修改时间	√
				ctime		create time 创建时间
				birthtime	文件创建时间(出生时间)		√
	文件重命名:  fs.rename(oldPath,newPath,fnCb)		移动文件
	创建目录:  fs.mkdir(path,fnCb)
	删除目录:  fs.rmdir(path,fnCb)

	* fs文件操作自己可以操作自己的
--------------------------------------------------------
包:
模块:
	* 模块和包其实是一个概念

	包里面可以有多个模块

node模块分类:
	内置模块/系统模块——http、fs
	第三模块

npm	node pakcage manage	node包管理器
	官网: https://www.npmjs.com/

	npm -v / node --version

	npm help	查看所有npm命令

	jquery

下载模块	npm install <包名、模块名>
		npm i <包名>

		npm install 包名 包名2....

		放到了 node_modules目录里面
卸载模块	npm uninstall <包名、模块名>

../	上级目录
../../	上上级目录
./	当前目录

自定义模块：
	exports.名字=值;	导出一个模块

	module.exports={}	批量导出一堆模块
	module.exports=function(){}
使用模块:
	var modA=require('mod_a');	Cannot find module 'mod_a'	×

	require('./mode_a');

文件夹形式定义模块：
	/a/index.js

文件夹形式定义模块2:
	pakcage.json	配置文件
		“main”:'./lib/interface.js'

使用模块的时候不想加 ./ ?
	可以

	把定义的模块放入到 node_modules文件夹里面
-----------------------------------------------------------
发布模块:
	test_mod

	1. 准备一个 pakcage.json	工程文件(项目、模块、包、里面描述任何东西)
		a). 新建
		b). 命令	npm init
				npm init --yes	 一下就生成
			name:	<包名称>
			version: <包版本号>
			description: <包描述信息>
			entry point: <入口文件>
			test command:  <demo用法>
			git repository:	<git仓库地址>
			keywords:	<包关键词>
			author:	<作者>
			license:	<开源许可>
	2. 编写index.js模块
	3. npm adduser
		username:
		password:
		Email:
	4. npm publish
		包重名问题

删除发布包：
	npm unpublish	提示拒绝删除
	npm unpublish --force	强制删除

	npm unpublish 包名 --force	删除包
=================================
数据解析:

前端：
	form:
		action
		name
		value
		method——GET、POST
	ajax——name、value、模拟了一个表单提交
	jsonp——模拟表单提交

	* 后台不关心到底前端使用何种技术(form、ajax、jsonp)

后台接收数据：
	其他语言里面  php  .net	接收数据，现成的
		$_GET
		$_POST

	一切得自己动手来写

GET:——走url，容量
	/abc?username=abc&password=123  -> {username:abc, password:123}

	username=abc&password=123  -> {username:abc, password:123}
		url2json

	querystring——系统自带的模块
		querystring.parse(str);	-> json
		querystring.stringify(json) -> str


	* 肯定尽量使用系统提供的，性能高

	url——提供各种url相关操作

	EADDRINUSE——此端口已被占用

		get=url.parse(url,true).query;
		url=url.parse(url,true).pathname;


		url.format(json);
POST:——不走url、容量大
	发送数据:——分块发送

	接收:——分块接收

	get数据比post数据先到达


	* 数据格式固定: username=abc&password=123

	req.addListener('data',function(s){
		str+=s;
	});

	req.addListener('end',function(){
		str
	})

	监听事件：  addListener/on

data_server.js
简易登录:
	ajax:

	user?username=xxx&passsword=xxxx
		retrun {err:0, msg:"xxxx"}


	server:
		根据用户访问地址，读取文件、处理接口

	假设： admin	admin123	成功

	小作业： 用户数据存放 文件里面
------------------------------------------------------
cookie:
	* 特性——每次会随着请求，发往服务器
	前端:
		addCookie(name,value,iDay);
		getCookie(name)
		removeCookie(name)

	关于请求：
		request header
		response header

	res.writeHead(状态码,{name:value});

	res.writeHead(200,{'Content-Type':'text/html; charset=utf-8'});	√
	res.writeHeader(状态码);

	解析cookie数据：
		a). replace，替换，querystring
		b). querystring.parse()


	querystring.parse(str,sep,eq);
	querystring.stringify(str,sep,eq);

服务器写cookie:
	res.writeHeader(200,{'Set-Cookie':'user=def'});
	res.writeHeader(200,{'Set-Cookie':['a=101','b=202','c=303']}); 

	* 头部里面信息，完全可以自定义的

	res.setHeader(name,value);	//设置头部

	res.setHeader('set-cookie','pass=12312312');

书写顺序：
	setHeader();
	writeHeader()
	write();
	end();


	cookie:
		|-a.html
		|-b.html
		|-/test
			|-get.html

		baidu.com

		www.baidu.com

		关闭浏览器，消失了


每次更改代码，都需要重启服务器?
	supervisor	更改完，代码以后，自己重启的

	之前:
		node 文件
	现在:
		supervisor 文件
	安装: 
		npm install supervisor -g
-------------------------------------------------------
文件操作:
数据解析服务器:
	get	
	post
	cookie-> ?
自定义模块:
	定义、使用
	发布
			</pre>
			<h4 id="q3">8-7</h4>
			<pre class="brush: js;" >	
				file:	文件操作
	fs
		fs.writeFile(path,内容,fnCb)
		fs.readFile(path,fnCb)
		fs.appendFile(path,内容,fnCb)
		fs.state(path,fnCb)
			ctime
			mtime
			
			方法:
				stat.isFile()
				stat.isDirectory()
		fs.rename(oldPath,newPath,fnCb)	重命名，移动文件
		fs.unlink(path,fnCb)
		fs.exists(path,fnCb)
		fs.mkdir()
		fs.rmdir()
		fs.readdir()

		判断文件还是目录?
			
模块:
	内置模块——http fs
	第三模块——npm 下载
		npm install xxx
		npm install xxx  xxx
		npm uninstall xxx
	自定义模块——
		定义：
			exports.xxx=xxx
			module.exports=function(){}
			module.exports={};

		使用:
			require('./xxx');
	发布模块:
		pakcage.json		npm init		npm init --yes
			"main":"入口文件"
		npm adduser
		npm publish
		npm unpublish 包名  --force
get数据解析:
	数据url里面
	
	querystring
		querystring.parse()	解析普通有规律的字符串
		JSON.parse()		解析 '{"a":1, "b":2}'

		querystring.stringify()	'a=1&b=2&c=3'
		JSON.stringify()	{a:1,b:2,c:3} -> '{"a":1, "b":2}'
	url:
		url.parse(url,true)	√
			.query
			.pathname

		url.parse(url).pathname
		url.parse(url,true).pathname

		url.format(json)
		url.resolve(原地址，替换path)

	get=urlLib.parse(req.url,true).query;
	url=urlLib.parse(req.url,true).pathname;
	
post数据解析:
	var str='';
	req.on('data',function(s){
		str+=s;
	});
	req.on('end',function(){
		str  ->  // a=1&b=2&c=3
	})
cookie:
	cookie在哪？
		req.headers.cookie	-> // a=1; b=2

			-> querystring.parse(cookie,'; ')

get、post、cookie、 都要挂到 req

	req.get.username
	req.post.password
	req.cookie.abc

服务端想给客户端种cookie?
	res.writeHead/writeHeader(状态码,{name:value})

	res.writeHeader(200,{'set-cookie':'a=1'})
	res.writeHeader(200,{'set-cookie':['a=1','b=2']})

	res.setHeader(name,value)

	res.setHeader('set-cookie','a=1')
	res.setHeader('set-cookie',['a=1', 'b=2'])

顺序:
	res.setHeader()
	res.writeHeader()
	res.write()
	res.end()
-------------------------------------------------------------
var oDate=new Date();  ->  浏览器自己包装过的时间

	变成统一时间:
		oDate.toUTCString()


	res.setHeader('set-cookie','a=1; expires='+oDate.toUTCString())

	path:
		res.setHeader('set-cookie','a=1; path=/; expires='+oDate.toUTCString())

	domain:
		res.setHeader('set-cookie','a=1; path=/; domain=localhost;  expires='+oDate.toUTCString())


	平时:
		res.setHeader('set-cookie','a=1; path=/; expires='+oDate.toUTCString())

ajax:
	oAjax.getResponseHeader('a')

	onreadystatechange	  资源加载
	
---------------------------------------------
session数据:
	后台的cookie， 存储在后台，服务器上，以文件形式存在
	容量

	cookie

	统计用户到访次数?


	http协议——无状态

	sessid
	生成sessid:
		now++	理论可以，但是实际不能用

		sessid被猜出来

		Math.random()

		Math.pow(Math.random,3)

		new Date().getTime()

	asfadsfasfd.data
		{visite:3}

定期清理session文件:
	20分钟清理一次
	20*60*1000

	3秒

	3000

	fs.stat()
		(now-mtime)/1000>20*60

get
post
cookie
session
----------------------------------------------------------
querystring
url——数据

path:
	path.normalize(url)		让路径变成合法
	path.basename(url)		当前path
	path.basename(url,ext)	
	path.dirname()			当前目录
	path.extname()		后缀名	√
util:
	util.inspect(obj)		把对象变成字符串形式	√
	util.inherits(子类，父类)	继承
	util.isDate()
	util.isArray()
	util.isFunction()
	util.isUndefined()
	     .....

	自己判断东西是否是个时间?
os:
	os.cpus()		获取cpu核数	√
	os.platform()		获取平台类型
----------------------------------------------------------
events:
	node里面最重要的模块之一
	
	事件，类似前端事件

	"订阅/发布"模式

	流水作业:
		

	材料->下锅->等一会->出锅->吃

	压缩:
		压缩东西->压缩->压缩包

	解析数据：
		get->post->cookie->session->业务逻辑->写回session-> 响应结束

使用:
	1. const EventEmitter=require('events').EventEmitter;
	2. var E=new EventEmitter()

	E.on('msg',function(){  	//addListener
		//code
	})

	E.emit('msg')

读取文件，
处理接口数据

	localhost:8081/user
		username-> admin
		password-> 123

	localhost:8081/news

E.emit()	有返回值

	如果有人监听了，返回true
	如果没有人监听，返回false
-----------------------------------------------------------
events其他东西：
	E.removeListener(名称,函数)	函数不能是匿名的
	
	E.removeListener(名称)	->   用法×的，第二个函数必须传

	E.removeAllListeners()	->  删除所有的

	E.removeAllListeners(type)	->  删除type这一个类的

	E.once(type,listener)	->  绑定一次(订阅一次)

	E.setMaxListeners(n)	设置最多监听数量

		默认 10个

		0	->   无限个
-----------------------------------------------------------
buffer:
	fs.readFile()
	req.on('data',function())

	二进制的流

	前端js，能操作二进制

	表现和 array有点类似
	
	Buffer 61 62 63 64>

	buffer用16进制的两位来表示

	new Buffer(string/buffer);

	new Buffer(number)	-> length的个数

	图片、音频等

buffer.toString()	变成人类可以看懂
	默认就是utf-8
		buffer.toString(‘utf-8’)
		buffer.toString('base64')

	base64:
		1. 工具
		2. file Reader
		3. node

	node转base64，没有头部

	data:image/jpg;base64,

	buffer转，废掉了

	*** buffer数据，千万别瞎转

其他小方法:
	buffer.indexOf('字符串'/buffer)		出现位置
	buffer.indexOf(东西,start)		
-------------------------------------------------
cookie
session数据解析:
events——
buffer——
path
os
util
			</pre>
			<h4 id="q4">8-14</h4>
			<pre class="brush: js;" >
				服务器：
	解析各种数据:
		get
		post
		cookie
		session
	流程:get -> post -> cookie -> session -> 业务 -> 写回session -> end	

	业务:
		1. 读取文件
		2. 接口数据
			/nav
				[{text:,href},{}]
	cookie:
		a=1; b=2   ->  {a:1, b:2}
	'{a:1,b:2}'  ->  {a:1,b:2}
events:
	深层次异步回调嵌套

	var EventEmitter=require('events').EventEmitter;
	
	var E=new EventEmitter();
	
	E.on/addListener(名称,function(arg1,arg2){

	})

	E.emit(名称，arg1,arg2.....)

	E.emit()	有返回值，此事件是否有人监听

	解除监听:
		E.removeListener(名称,函数名)
		E.removeAllListners(名称);

	E.once(名称,函数)
buffer:		和数组有点类似

	二进制数据:图片、音频、视频等等

	用 16进制2位表示

	'abc'	-> a  ->  97
		

	var buffer=new Buffer(字符串/number/编码);

	new Buffer(3)  -> 向内存申请了3个空间(留有一些垃圾，每次看到都不一样)

	buffer-> 字符串:
		buffer.toString()
		buffer.toString('utf-8'/base64)

		* 二进制数据，不能toString，以后再继续使用

		buffer转base64，默认没有头信息
			头信息:  data:image/png;base64,

	toString: 和数字打交道
		toString(进制)
		
		10	8	2	16

	小方法:
		buffer.indexOf(字符串/buffer,start);

	buffer.length
--------------------------------------------------------------
var str='width';	->  
		str.substring(s,e)
		str.slice(s,e)
var arr=['w','i','d','t','h'];  ->  
		arr.join('').substring(1,3).split('')
		arr.slice(1,3)
var buffer=new Buffer('width');

	buffer.slice(s,e)	截取buffer
	buffer.slice(s)		不给结束位置，直接截取到最后

buffer里面没有有split:
	a). toString().split()	不好
	b). 自己使用slice模式 split
		bufferSplit(哪个buffer，用谁切)
--------------------------------------------------------------
var arr=[1,2,3,4];		Array
arr.push/pop/indexOf

Array.from()

	类身上也可以有方法

function Person(){}

Person.show=function(){}
--------------------------------------------------------------
var buffer=new Buffer('abc');
buffer.indexOf()
buffer.slice()
buffer.toString()

Buffer.concat([a,b])

之前接收post数据方式:
	var arr=[];
	req.on('data',function(s){
		arr.push(s);
	})
	req.on('end',function(){
		var buffer=Buffer.concat(arr)
	})
---------------------------------------------------
post:	容量大		平时上传文件，post
	两种方式：
		1. application/x-www-form-urlencoded	默认
			普通post数据
			a=1&b=2&file=a.txt
		2. multipart/form-data
			文件型post数据

------WebKitFormBoundaryvRBkOhg6DJgEjvdr
Content-Disposition: form-data; name="user"


abc
------WebKitFormBoundaryvRBkOhg6DJgEjvdr
Content-Disposition: form-data; name="age"

12
------WebKitFormBoundaryvRBkOhg6DJgEjvdr
Content-Disposition: form-data; name="file1"; filename="1.txt"
Content-Type: text/plain

asdfasdf
------WebKitFormBoundaryvRBkOhg6DJgEjvdr--
==========================================
深度解析post数据:
1. 找到大分隔符
	------WebKitFormBoundaryQl7wNOSgz89z5LfM
	----WebKitFormBoundaryCAMDx3OltAueVPkp		少了两个 --

	req.headers['content-type']
		
2. 整理格式
	<分隔符><换行>Content-Disposition: form-data; name="user"<换行><换行>abc<换行>
<分隔符><换行>Content-Disposition: form-data; name="age"<换行><换行>12<换行>
<分隔符><换行>Content-Disposition: form-data; name="file1"; filename="1.txt"<换行>Content-Type: text/plain<换行><换行>asdfasdf<换行>
<分隔符>--<换行>
3. 开切
	，<换行>Content-Disposition: form-data; name="user"<换行><换行>abc<换行>
，<换行>Content-Disposition: form-data; name="age"<换行><换行>12<换行>
，<换行>Content-Disposition: form-data; name="file1"; filename="1.txt"<换行>Content-Type: text/plain<换行><换行>asdfasdf<换行>
，--
4. 删除数组首尾
\r\nContent-Disposition: form-data; name="user"<换行><换行>abc\r\n，
\r\nContent-Disposition: form-data; name="age"<换行><换行>12\r\n，
\r\nContent-Disposition: form-data; name="file1"; filename="1.txt"<换行>Content-Type: text/plain<换行><换行>asdfasdf\r\n

	<换行>  ->  \r\n
5. 每一条，用两个换行切
Content-Disposition: form-data; name="user"<换行><换行>abc，
Content-Disposition: form-data; name="age"<换行><换行>12，
Content-Disposition: form-data; name="file1"; filename="1.txt"<换行>Content-Type: text/plain<换行><换行>asdfasdf

封装函数:
	parsePostDeep(req,function(fileds,files){

	})
--------------------------------------------------------
第三方模块:
	formidable	上传文件——以单文

	1. const formidable=require('formidable');
	2. var form=new formidable.IncomingForm();
	3. form.parse(req,function(err,fileds,files){
	        console.log(fileds, files);
	    });

	files.file1
		.size
		.path	//临时把文件放到 c盘里面
		.name
		.type
		.lastModifiedDate

	文件上传:
		cross-device link not permitted	不允许跨磁盘移动文件
		1. 配置上传文件路径	form.uploadDir='upload';
		2. ？

	上传多个文件:
		a).前端-> 配置form -> 添加一个属性 multiple
		b).form.multiples=true;
			变成数组
======================================
multer:	做文件上传——二进制流

1. npm install multer
2. 引入
	const multerLib=require('multer');
3. 配置上传目录
	var multer=multerLib({dest:'upload'});
4. 允许哪些文件上传
	var multerHandler=multer.any();
5. 调用
    multerHandler(req,res,function(){
        console.log(req.files);
    });
----------------------------------------------------------
流:
	就是一组连续的数据-"流"
		文件流、网络流、物流信息流
之前：文件操作
	读取	readFile
		一下把文件读取到内存中

		内存不足、卡顿

		造成 IO峰值

		数据混乱

		耗时

		操作文件，大小限制
流优点：
	读取一点，扔一点，顺序好的

流分类：
	读取流		req
	写入流		res
	读写流		压缩
			源文件 -> 写入
----------------------------------------------------------------
写入流:
	之前:fs.writeFile()

	var ws=fs.createWriteStream(文件名)
	ws.write(东西);
	ws.end();

	ws.on('finish',function(){
		
	})
----------------------------------------------------------------
读取流:
	var rs=fs.createReadStream('aaa.txt');

	var arr=[];
	rs.on('data',function(b){
	    arr.push(b);
	});
	rs.on('end',function(){
	    var buffer=Buffer.concat(arr);
	    console.log(buffer.toString());
	});

	rs.on('error',function(err){
    		console.log('404');
	});

	会出现异常、报错，如何屏蔽？
		try...catch(){}

		不行的，try捕获是程序异常，流操作，走的系统
---------------------------------------------------------------------
管道:
	pipe()

	源头.pipe(目标)

	读取.pipe(写入)
---------------------------------------------------------------------
读写流:
	压缩——
		压缩格式: rar, zip, 7z,gzip

		gzip  ->  gz  -> liunx里面一种常见压缩格式

		gz	√

	zlib  -> 压缩东西

	1. const zLib=require('zlib');
	2. 选择一个压缩模式
		var gz=zlib.createGzip();
	3. 准备两个流
		var rs=fs.createReadStream('aaa.txt');
		var ws=fs.createWriteStream('aaa.txt.gz');

	4. 压缩
		rs.pipe(gz).pipe(ws);

	gz压缩格式特点：
		压缩文件会跟着压缩包名字走

http服务器(请求)->开启gzip压缩:

	gz压缩率，能到 50%

	默认情况下，下载文件了

	设置头：
		res.setHeader('content-encoding','gzip')

	开启gz压缩的时候，每个请求，都要压缩？
----------------------------------------------------
post数据深入解析
	formidable
	multer
流:
	读取流	req
	写入流	res
	读写流	压缩

grunt	慢	文件,pkg
gulp	快
	gulp.src(xxx).pipe(xxx).pipe(...)
			</pre>
			<h4 id="q5">8-24</h4>
			<pre class="brush: js;" >	
				buffer:
	var buffer=new Buffer(10);

	buffer.indexOf(找东西,start)
	buffer.slice(start,end);

	接收：
		str+='xxx'

		var arr=[];
		Buffer.concat(arr)
post数据:
	enctype="application/x-www-form-urlencoed"	普通数据
		  formdata	文本型
	a). 原生、一点点切
	b). formidable
		var formidable = require('formidable');
		formidable.uploadDir='upload'
		var form = new formidable.IncomingForm()

		form.parse(req,function(err,fields, files){

		});
	c). multer
		var multer  = require('multer')
		var upload = multer({ dest: 'uploads/' });

		var multerLib=upload.any();

		multerLib(req,function(){
			req.body
			req.files
		});
流操作:
	readFile
	appendFile

	流——一组连续数据

写入流:	response
	var ws=fs.createWriteStream('文件名字');
	
	ws.write(东西);
	ws.end();
		
	ws.on('finish',function(){

	})
读取流:	request
	var rs=fs.createReadStream('a.txt')
	var arr=[];
	rs.on('data',function(b){
		arr.push(b);
	});
	rs.on('end',function(){
		var buffer=Buffer.concat(arr)
	})
	rs.on('error',function(){
		
	})
pipe:	管道
	源头.pipe(目标)

	rs.pipe(ws)

	request.pipe(response)
读写流:
	压缩:
	gz

	zlib

	const zLib=require('zlib');
	var gz=zLib.createGzip();

	gz特点: 里面文件跟着压缩文件名走的

	压缩http传输:
		* 以后咱的服务器，一定要开发 gzip
-----------------------------------------------------
文件下载:

	res.setHeader('content-disposition','attachment');  //所有文件都下载

	res.setHeader('content-disposition','attachment;filename="abc.txt"');


	文件类型:   rar   exe   png  jpg
-----------------------------------------------------
多进程、多线程:
	一个应用可以拥有多个进程，一个进程里面可以拥有多个线程	

	进程(process): 重，资源独享，一个进程拥有一套完整资源(内存、中断等)
		         安全高、通信难度高
		一个班级
	线程(thread): 轻、资源共享、安全低、通信简单
		一个班级里面同学

	JAVA:	多线程
		tomcat
	PHP:	多进程
		apache

	nginx: 多进程+多线程服务器

多线程操作:
	var count=0;

	count++
	count++
	count  ->  2

	count++:
	a). var a=count;
	b). var b=a+=1;
	c).  count=b;


	count++		count++
	a=0			a=0
	a+=1 -> b=1		b=a++
	count=b		count=b

	count=1		count=1

		count=1

	线程间同步:
		信号量、互斥锁、缓存区

	js 为了用户使用方便，而不是为了追求极致性能

NodeJs不支持多线程，
	NodeJs多进程

	NodeJs异步回调机制，为了接近线程操作性能

	NodeJs非阻塞、异步IO

	区别:
		    好用		安全		通信
	多进程	    好用		安全		恶心
	多线程	    难用		不安全		简单
-------------------------------------------------------------
cluster:——集群

	”集群“——一堆物理机器，组合起来变成并行网络

	cluster——一个进程、分裂出很多子进程

	对应的就是cpu核数

主进程:
	a). 分裂工作进程
	b). 子进程崩溃，重启
子进程(工作进程):
	才是主要工作，文件读取、服务器搭建.....


使用：
	const cluster=require('cluter');

	cluster.isMaster		是否是主进程
	cluster.isWorker	是否是工作进程


	进程进程id:  pid
		process.pid	

子进程崩溃事件:
	cluster.on('exit',function(){  //有人崩溃

	})

	cluster.on('exit',function(worker,code,signal){
		console.log(worker.id);
		cluster.fork();
	});
----------------------------------------------------
以后:
	const cluter=require('cluster');

	if(){
		分裂
		重启
	}else{
		以前代码
	}
----------------------------------------------------
数据库:
	mysql,sql server, oracle,db2, noSql......

	mysql

	php ->  wamp

		图形界面:  phpmyadmin
基本概念:
	数据库		文件夹
	表		文件


首先确保，mysql已经安装完毕

命令行:
	mysql --version

	登录:   mysql -uroot -p 回车

	show databases;	-> 多少个数据库
	
	创建数据库:
		CREATE database 库名字;

	使用某个库:
		use 库名;

	列出所有表:
		show tables;

	建表:
		CREATE table 表名(字段 字段类型, 字段2 字段类型....)

		字段类型:
			VARCHAR	字符串
			INT		数字
			TEXT		大量文本
	*往表里面添加数据:
		INSERT INTO 表名 VALUES(值1，值2)
		INSERT INTO 表名(字段,字段2) VALUES(值1，值2);
	*查询数据:
		SELECT 字段,字段2 FROM 表名;
		SELECT * FROM 表名

		可以带条件查询:
		SELECT * FROM 表名 WHERE 条件
	更新数据:
		UPDATE 表名 SET 字段=值 WHERE 条件;
	删除:
		DELETE FROM 表 WHERE 条件;

	描述表结构:
		describe 表名;

	删除:
		drop table 表名;

图形操作数据库:——规划整个数据库
	数据库设计规范:
		一般id ->ID
		长度    -> 2的几次方
	-------------------------------------------

	建数据库、建表

	phpmyadmin

	-------------------------------------------
	ID	username	password
	-------------------------------------------
	1	zhangsan	123456
	-------------------------------------------
	2	lisi		123456
	-------------------------------------------

	ID:
		a). 自增、主键
		b). GUID  通过程序可以生成，随机，很难破解



	创建表语句:
		CREATE TABLE `2016-8-28`.`user` ( `ID` INT(32) NOT NULL AUTO_INCREMENT , `username` VARCHAR(64) NOT NULL , `password` VARCHAR(64) NOT NULL , PRIMARY KEY (`ID`)) ENGINE = InnoDB;
	添加语句:
		INSERT INTO `user` (`ID`, `username`, `password`) VALUES (NULL, 'admin', 'admin123'), (NULL, 'abc', 'abc123');
-----------------------------------------------------
mysql_connect()
mysql_query();
-----------------------------------------------------
node关联mysql:
	node本身不支持任何数据库

	使用第三方模块:

* 从数据库里面取出来数据 ->  数组

	[{},{},{},{}]
------------------------------
node中使用ES6东西:
	之前:node a.js
	现在: node --harmony a.js
------------------------------
使用:
1. npm install mysql
2. node里面如何连接数据库
	var db=mysql.createConnection({
		host:	'localhost',
		user:	'root',
		password:	'xxxx',
		database:	'哪个数据库'
	});
3. 编写sql
	db.query(sql,function(err,data){

	});
-----------------------------------------
新闻:
	接口说明:
		1001	数据库方面有问题
		1002	新闻添加成功
		1003	获取新闻成功
		1004	获取新闻失败


	添加:
		news?act=add&title=xxx&href=xxx
			return  {code:1001/1002, msg:""}
	获取:
		news?act=get
-----------------------------------------
vue——跟angular一样
	区别:
		angular	重、pc
		vue		轻、移动端
-----------------------------------------
用户注册、登录:
	接口:
		user?act=xxx&username=xxx&password=xxx

			act: 
				add/login
		
			return {err:0/1, msg:""}
-----------------------------------------------------
密码等重要东西，在数据库中，也不可能明文显示
-----------------------------------------------------
加密:
	加密方式： md5,SHA1, SHA126.....

	md5: Message Digest Algorithm MD5	√
		强度不错

		签名
	
	和其他程序加密一模一样

	SHA: Secure Hash Algorithm
		'曾经'美国军用加密方式	166777612T
		加密强度极高

	md5、SHA 单向的，一旦加密完事，解不了

		暴力破解

crypto:
	123456   ->  e10adc3949ba59abbe56e057f20f883e	32位 小写
		        e10adc3949ba59abbe56e057f20f883e

		        0192023a7bbd73250516f069df18b500

	()*%)#*%)(#*%)(#*%)($#%12312321

使用：
1.  const crypto=require('crypto');
2. 生成加密方式
    var obj=crypto.createHash('md5');
3. 更新数据
    obj.update(数据);
4. 签名
    var res=obj.digest('hex')
    res  ->  xxxx
------------------------------------------
注册:	->  加密存储
登录:      ->  加密完以后比较

	md5(md5('123456'))

	双重加密
------------------------------------------
上官网:
	英文
------------------------------------------
基于node
	node -v
	npm -v
------------------------------------------
grunt:	自动化构建工具
使用流程：
1. 安装命令环境
	npm install -g grunt-cli

	验证安装ok？
		grunt --version
2. 安装项目里面使用grunt(本地grunt)
	npm install grunt
3. 准备两个文件
	Gruntfile.js	配置具体grunt任务
	package.json	工程文件(配置文件)——说明此项目需要东西
4. 基本结构
	module.exports=function(grunt){
	    //js代码
	    /*for(var i=0; i<10; i++){
	        console.log(i);
	    }*/
	    grunt.registerTask('default',function(){
	        console.log('默认任务');
	    });
	};
5. 编写真正任务:
	模块(插件)：
		a). contrib-xxxx 由grunt官方开发组件
		b). abc	由第三方开发模块
	运行grunt程序:
		在终端:
			grunt		->  运行默认(default)
			grunt <任务名>
			grunt  <任务名>:<子任务名>

	压缩js:

	*	所有文件
	**	所有目录

	expand:true,	//分开
             cwd:'src',	//当前工作目录
             src:'*.js',	//源文件
             dest:'dest'	//目标目录
----------------------------------------------------
	npm install grunt	只是安装到本地
	npm install grunt --save	 不仅会安装到本地，而且会入到package.json的dependencies依赖里面
	npm install grunt --save-dev	不仅会安装到本地，而且会入到package.json的devDependencies依赖里面

	* 以后: npm install grunt --save-dev
----------------------------------------------------
以后拿到别人项目：
	a). npm install
	b). 需要命令
		约定俗称:
			npm run start  /npm start
			npm run dev  /npm dev
			.....	

		在package.json里面：
			"scripts": {
			    "start": "grunt"
			  }

grunt注意:
	任务名必须跟着模块(插件名)
----------------------------------------------------
gulp:

----------------------------------------------------
文件下载:
	res.setHeader('content-disposition','attachment;filename=xxx.xx');
多线程、多进程:
	

	cluster——集群
mysql:	数据库
	
如何node关联？

加密:  crypto
	md5(md5(md5(md5())))
grunt:
gulp:
			</pre>
			<h4 id="q6">9-4</h4>
			<pre class="brush: js;" >	
				cluster:——集群
	主进程:
		功能: 分裂子进程、子进程如果崩溃，重启

	const cluster=require('cluster');
	const os=require('os');

	var cpus=os.cpus().length;

	if(cluster.isMaster){
		for(var i=0; i<cpus; i++){
			cluster.for();
		}
		cluster.on('exit',function(){
			cluster.fork();
		})
	}else{
		//工作进程
		//http服务器、fs
		http.createServer(....);
	}
mysql:
	命令行:
		测试
		mysql -uroot -p
		show databases;
		CREATE database 名称;
		use 库名
		show tables;
		CREATE table 表名(字段 字段类型,字段2 字段类型.....)
		describe user_table;	列出表结构
		
		增:
		INSERT INTO 表(字段,字段2) VALUES(值，值2)
		INSERT INTO 表 VALUES(值，值2)
		查:
		SELECT 字段,字段2 FROM 表;
		SELECT * FROM 表		
			带条件:
			SELECT * FROM 表 WHERE 条件
		删:
			DELETE FROM 表;	不推荐
			DELETE FROM 表 WHERE ;
		改:
			UPDATE 表 SET 字段=value WHERE 条件;

	node中关联数据库:
		mysql

		1. const mysql=require('mysql');
		2. 
		  var db=mysql.createConnection({
			host:	'数据地址',
			user:	‘root’,
			password:	'xxxx',
			database:	'哪个库'
		  });
		3.  db.query(sql,fnCb)

		* 从数据库中，取过来，都是一个数组
md5:	保密
	crypto

	1. const crypto=require('crypto');
	2. var obj=crypto.createHash('md5');
	3. obj.update('msg');
	4. var res=obj.digest('hex')

	双重....
grunt:	自动化构建工具
	编写任务

	Gruntfile.js	->  编写任务文件
	pakcage.json	->  工程文件
		npm init 
		npm init --yes

1. 安装命令行工具
	npm install -g grunt-cli

	验证是否？
		grunt --version/-v
2. 安装本地grunt
	npm install grunt --save-dev
3. 编写Gruntfile.js
	
	cssmin	压缩css
		grunt-contrib-cssmin

	watch	
		grunt-contrib-watch
gulp:——
	a). 编写简单一点(贴近node语法)
	b). gulp比grunt快
		grunt 以文件为单位
		gulp  以流

	官网: http://gulpjs.com/

	gulpfile.js	->   编写任务
	pakcage.json	

1. 安装gulp命令环境
	npm install -g gulp-cli

	验证?
		gulp --version
2. 安装本地gulp
	npm install gulp --save
3. 编写任务
	a).  const gulp=require('gulp');

	b). 
	    gulp.task(任务名,function(){
	        console.log('This is aaa task');
   	    });

	gulp.task(任务名,fnCb)
	gulp.src();	//源文件
	gulp.dest();	//目标
4. 压缩js
	gulp.src().pipe(任务).pipe(gulp.dest())

压缩图片:
	gulp-imagemin

gulp-htmlmin
----------------------------------------------------
模块化:
	seajs	//停更了，报废了
	requireJs
----------------------------------------------------
node天生模块的
	const http=require();
	const fs=require()
----------------------------------------------------
browserify:——客户端书写模块
	可以像书写node一样

	偏向：js

	官网: http://browserify.org/


	browserify  xxx

使用:
1. 安装命令环境
	npm install -g browserify

	验证？
		browserify --version

	自带了一堆模块(跟node保持基本一致)
	
2. 使用
	bundle.js	->  打包完以后文件
	
	browserify ./a.js -o bundle.js

watchify:——监听，基于browserify

安装:	npm intall watchify -g
	
	watchify ./a.js -o bundle.js
----------------------------------------------------
压缩(工具)->模块化（seajs,requireJs（r.js））->grunt\gulp-> browserify/watchify -> webpack ->xxx
----------------------------------------------------
webpack:——一切资源都是模块
	js、css、图片.....
	
	官网: http://webpack.github.io/
使用:
1. 安装命令环境
	npm install webpack -g

	验证？
		webpack --version

		webpack --help


	常用命令:
		webpack
		webpack -w	监听
		webpack -p	压缩
		webpack -w -p	监听、压缩

运行：
	webpack ./a.js bundle.js
	webpack ./a.js bundle.js -w
	webpack ./a.js bundle.js -p
	webpack ./a.js bundle.js -w -p
-----------------------------------------
css模块：
	加载器   loader

	css-loader
	style-loader

	require('style!css!./style.css');
-----------------------------------------
json文件：
	引入json数据
	json-loader
raw:
	普通文本
	raw-loader
-----------------------------------------
图片:
	url-loader

	url?limit=16000
		limit 限制base64临界点
			小于limit就是base64
			大于 路径
-----------------------------------------
服务器:
	之前:  webpack ./index.js bundle.js
	
	webpack-dev-server

	npm install webpack-dev-server

	浏览器里面:  localhost:8080

	webpack
	webpack-dev-server  启动服务
	
-----------------------------------------
配置文件:
	loader,入口，出口文件....

	webpack.config.js
-----------------------------------------
插件(模块):
自动打开浏览器并且自动刷新浏览器:	

	下载->引入

	html-webpack-plugin
	open-browser-webpack-plugin

	* 必须 webpack-dev-server

	* 访问: http://localhost:8080/index.html


	plugins:[
		new Plugins(),
		new Plugins(),
		new Plugins(),
	]
------------------------------------
webpack
	a). 模块
		本身带了很多模块——js
	b). 其他资源
		需要加载器  loader
		https://github.com/webpack/webpack
	c). 其他插件(模块)
		plugins:[]
------------------------------------
bower:
	类似npm	npm用在后台(node)

	bower 前端包管理器
使用：
	npm install bower -g


	bower help	查看帮助

常用命令:
	bower search	查找包资源
	bower install <package>
	bower uninstall/prune <package>
	bower info <package>	信息


bower和github强度有关系

	bower cache list	缓存
	bower cache clean	清除缓存

-------------------------------
npm自己编写包:
	编写
	npm init	->  pakcage.json
	npm adduser
	npm publish
-------------------------------
自己编写自己bower包:
	1. bower init	-> bower.json
	2. 把你需要东西
		传到github上

	3. bower register zns-bower git地址	//bower注册到git上
	
-------------------------------
yoman:	脚手架

	官网: http://yeoman.io/

	帮你创建一个工作流:
	grunt/gulp+bower+yo

npm install yo -g

yo命令

	yo	安装完脚手架以后

	1. npm install
	2. bower install
	3. gulp
-------------------------------
php -> smarty
-------------------------------
前端、node
-------------------------------
artTemplate:
	前端
	node

	官网: 性能高、nodeJs

	template.js	支持简洁语法	{{name}}
	template-native.js	支持原生js语法	<%=xxx%>

前端:
	1. 准备一个模板
		<script type="text/template" id="tpl">
		        <h3>{{name}}</h3>
		</script>
	2. 准备数据
		var data={
		    name:'welcome art'
		};
	3. 数据渲染到页面
		var html=template('tpl',data);

            	oBox.innerHTML=html;
	
-------------------------------
node:
	1.npm install art-template
	2. 引入
	const template=require('art-template');
	3. template(模板,数据)

-------------------------------
模板引擎：
	1. artTemplate、ejs
		非侵入式
	2. jade
		侵入式

jade:	侵入式
	优点：语法极其简洁

	zenCoding -> emmet  
	
	#box
	.box

	jade-> pug

	https://pugjs.org/api/getting-started.html

	靠缩进活着呢
	jade自动区分单双标记

使用:
1. npm install jade
2. const jade=require('jade');
3. 
    jade.render('abc');	->  <abc></abc>
    jade.renderFile(模板文件,{})

    jade.renderFile(模板文件,{title,data, pretty:true})
-----------------------------------
属性:
	<input type="button">	->   input(type='button')
	
	input(type=button, value=aaa....)
-----------------------------------
内容:
	<div>welcome</div>    ->   div welcome

内容文本原样输出：
	| abc

	script.
		var a=12;
	style.
		body{background:red}
-----------------------------------
简写:
	.red	-> 	<div class="red"></div>
	#box	->	<div id="box"></div>
-----------------------------------
语句:
	
	-var a=12

	-for(var i=0; i<10; i++)
-----------------------------------
textarea
    include a.txt
style
    include a.css
script
    include a.js
-----------------------------------


grunt
gulp
browerify
watchify
webpack -w/p
bower
yoman

artTemplate

jade

ejs

原生node+artTemplate+jade+ejs开发项目
-------------------------------------------------------
node框架:
	express
			</pre>
			<h4 id="q7">9-11</h4>
			<pre class="brush: js;" id="q7">	
				grunt
gulp
browserify
webpack
bower	npm
yoman——提供脚手架
----------------------------------------------
模板引擎:
	artTemplate
		template.js	简洁语法 	{{abc}}
		template-native.js	<%=abc%>	√
	前端:
		1. 引入
		2. 准备一个模板
			<script type="text/template" id="tpl">
				<h3>{{msg}}</h3>
			</script>
		3. 准备数据
			var data={
				msg:'welcome'
			};
		4. 渲染
			var html=template('tpl',data);	//template(模板id,数据)
			oBox.innerHTML=html;
	后台:
		1. 下载
			npm install art-template
		2. 引入
			const template=require('art-template');
		3. var html=template('模板地址',data)

		*模板地址-> 不加后缀
----------------------------------------------
jade:——pug	 侵入式模板引擎
	优势: 简洁无比

	语法规则: 缩进

	npm install jade/pug

普通文本输出：
	div
		| span


语句:
	- var a=12

	- for(var i=0; i<10; i++)

	- if a<10
----------------------------------------------
嵌入式模板引擎:	ejs

	官网: http://www.embeddedjs.com/

ejs.render('<div><%=msg%></div>',{msg:'welcome'});	不常用

ejs.renderFile(模板地址,数据,fnCb)

输出内容语法:
	<%=aaa%>	输出内容

	<%=a%>	√
	<%= a%>	√
	<%= a %>	√
	<% =a%>	×

ejs注释:
	<%//这是注释%>

	<%/*
	    这是多行
	    注释
	*/%>
连接成一行:
	<%=a -%>
语句:
	<%语句%>

	<%var a=12;%>
	<%
		var json={a:'apple',b:'banana',c:'absolute'};
		var arr=['width','height'];
	%>

	<%for(var i=0; i<10; i++)%>
非转意输出:（html）
	<%-a%>

ejs语法规则:
	a). <%=xxx%>
	b). <%语句%>
	c). <%-xxx%>	
include:
	<%include header.html%>
自定义标记：
	ejs.delimite='$$';
---------------------------------------------------------
咱选择: ejs
---------------------------------------------------------
框架:
express——node,web框架

	封装一堆函数，扩展一些功能

	增强型框架，不会破坏原有node功能

	request,response

	node->服务器、处理数据、发送数据、文件操作、路由....
---------------------------------------------------------
使用:
	1. npm install express
	2. const express=require('express');
---------------------------------------------------------
服务器:
	const express=require('express');

	var app=express(); //创建一个服务器

	app.listen(8081);
---------------------------------------------------------
supervisor	
---------------------------------------------------------

get:
	app.get(地址,fnCb)

	app.get(‘/’,function(req,res){
		res.write/end

		res.send(string/json/array....) //  write+end
	});

	* 以后统一用send

	app.get('/b.html',function(req,res){	//b.html   b.html?a=1&b=2
		
	})

get数据:
	req.query

简易登录:
	读取文件-> fs.readFile -> 文件下载

	需要设置头部:
		a). res.setHeader('content-type','text/html'); 
		b). res.set('content-type','text/html');	//express提供

		res.status(404)
		or:
		res.statusCode=404;

		res.status(404).send(data)	√
		res.send().status()		×

	
地址: 可以填写正则
	app.get(/\/|\/index/,function(req,res){
    		res.send('这是首页');
	});

	app.get(/^\/news/,function(req,res){
    		res.send('这是新闻相关页面');
	});
--------------------------------------
post:
	app.post(path,fnCb);

	app.post('/',function(req,res){
    		res.send('访问post根');
	});
--------------------------------------
无视请求方法:（不管get，post都会执行）:
	a). app.use(地址,fnCb);	√
	b). app.all(地址,fnCb);

	如果同时有，get和use，谁在上面先执行

中间件:（本质就是一个功能函数）
	app.use(中间件)

解析post数据:
	body-parser

	1. const bodyParser=require('body-parser');
	2. 调用中间件
	    app.use(bodyParser.urlencoded({extended:false}))

		extended:false
		limit		大小限制，默认100
	3. req.body
--------------------------------------
中间件——类似流水线
	处理1->处理2->处理3.....

自己写自己中间件，模拟body-parser
	app.use(function(req,res){	//普通
		
	})

	app.use(function(req,res,next){	//普通

	})

	app.get(path,function(req,res,next){})/post

--------------------------------------
get数据:	req.query
post数据:	body-parser
		-> 解析 post普通数据  (application/x-www-form-urlencoded)

		->multipart/form-data （文件型数据） 文件上传
multer:（文件上传）
	1. const multerLib=require('multer');
	2. 配置上传目录
	   var multer=multerLib({dest:'upload'})
	3. multer.any();

	4. req.files
		fieldname	字段名称
		originalname	源文件名称
		mimetype	文件类型
		path		文件路径

两者相结合
--------------------------------------	
cookie数据:
	解析客户端cookie数据
		a). req.headers['cookie']
			a=1; b=2; c=3
		b). cookie-parser
			const cookieParser=require('cookie-parser');

			//调用
			app.use(cookieParser());

			req.cookies

	写cookie:
		a). res.setHeader('set-cookie','a=1')  //原生node
		b). res.cookie(name,value)

		设置过期时间:
			res.setHeader('set-cookie','a=1;expires=oDate')
			 
			res.cookie(name,value,options)

			{maxAge:毫秒，path:'/'}	    20*60*1000
--------------------------------------
session数据:
	cookie-session
		瑕疵: req.session数据并没有看到，但是可以使用

	1. const cookieSession=require('cookie-session');
	2. 使用
	app.use(cookieSession({
	    name:'zns_sessid',	//session名称
	    keys:['aaa','bbb','cccc'],  //循环签名session
	    maxAge:20*60*1000	//过期时间
	}));

	3. req.session.xxx
	-----------------------------------------
	express-session:
	1. const expressSession=require('express-session');
	2. 使用
		app.use(expressSession({
		    secret: 'abc',  //加密，名字
		    resave: false,  //如果你有更好session存储的地方,否则在false
		    saveUninitialized: true,  //初始化存储
		    cookie: { maxAge: 20*60*1000}
		}));
	3. req.session
--------------------------------------
读完文件（发送文件）:
	a). fs.readFile()
		-> 默认是下载，所以设置头部
	b). res.sendFile(path)
		注意:  路径必须是绝对的

	res.sendFile(__dirname+'/download.html');	√

	or:

	res.sendFile('download.html',{root:__dirname});
--------------------------------------
文件上传:  multer
--------------------------------------
文件下载:
	a). 直接用 fs.readFile   什么都不做处理
	b). 原生node:
		res.setHeader('content-disposition','attachment;filename=xxxx');
	c). res.download(filename)
	     res.download(filename,newName)	√
--------------------------------------
ejs
jade（pug）
--------------------------------------
ejs和express结合:
	const ejs=require('ejs');

	//配置
	server.set('views','ejs'); //设置模板目录
	server.set('view engine','ejs'); //设置模板引擎
	
	res.render(模板,数据)

		* 模板后缀必须ejs
--------------------------------------
jade配合express:
	const jade=require('jade');

	//配置
	server.set('views','xxx'); //设置模板目录
	server.set('view engine','jade'); //设置模板引擎
	
	res.render(模板,数据)

		* 模板后缀必须jade
--------------------------------------
consolidate(bluebird): 好多模板的集合	√

	使用:
	const consolidate=require('consolidate');

	配置:
	server.set('views','template'); //设置模板目录
	server.set('view engine','html'); //设置模板名称
	server.engine('html',consolidate.ejs); //对应上模板引擎
	
	res.render(模板地址,数据);
--------------------------------------
路由->规划、整理所有路径
	resful	接口

	localhost:8081/user	-> 用户主页面
	localhost:8081/user/login	-> 用户登录页面
	localhost:8081/user/reg		-> 用户注册页面
	localhost:8081/user/email	-> 页面邮件页面

	localhost:8081/news		
	localhost:8081/news/add
	localhost:8081/news/delete

编写方式：
	一、
	var userRouter=express.Router(); //user的router

	userRouter.get('/',function(req,res){
	    res.send('用户主页面');
	});
	userRouter.get('/login',function(req,res){
	    res.send('用户登录页面');
	});

	server.use('/user',userRouter);  //使用

	二、
	const express=require('express');

	var router=express.Router();

	module.exports=router;	//导出

	router.get('/',function())
	router.get('/login',function())

	外界使用:
	server.use('/user',require('./router/user'));
------------------------------------------------
套页面:
------------------------------------------------
静态页面:
	images
	css
	js
		----> 静态资源
	index.html
	contact.html
	news.html
	list.html
		-----> 模板页面


	多级路由时候，一定注意静态资源路径
		之前: css/style.css
		最好: /css/style.css
-------------------------------------------------
express——中间件、路由
	数据: body-parser,cookie-parser.....

	express.Router();

模板引擎:
	ejs、jade
-------------------------------------------------
tieba.badu.com
zhidao.baidu.com
ting.baidu.com
bbs.zhinengshe.com
	虚拟主机
			</pre>
			<pre class="brush: js;" id="q8">	
			</pre>
			<pre class="brush: js;" id="q2">	
			</pre>
	  	 </div>	 	
	  </div>
	  
	   <!--返回顶部-->
	  <div id="div-Top">
		  	<dl>
		  		<dd>
		  			<img src="../../img/weixin-icon02.png"/></li>
		  		</dd>
		  		<dt class="weixin">
		  			<div></div>
		  		</dt>
		  		<dt class="to_top">
		  			<div></div>
		  		</dt>
		  		
		  	</dl>
	  </div>
	</body>
</html>
